# PNMSimulator

## Table of Contents

- [1. Overview](#1-overview)
- [2. CXL-PNM Architecture](#2-cxl-pnm-architecture)
- [3. Synthetic Trace Mode](#3-synthetic-trace-mode)
- [4. Real Application Trace Mode](#4-real-application-trace-mode)
- [5. How to Build](#5-how-to-build)
- [6. How to Run with Synthetic Trace Generator](#6-how-to-run-with-synthetic-trace-generator)
- [7. Code Structure](#7-code-structure)

## 1. Overview

PNMSimulator is a cycle-accurate performance simulator that models the behavior
and timing of CXL-based processing-near-memory (PNM) system. PNMSimulator
currently supports modeling execution of SparseLengthSum (SLS) operations in
PNM block.  PNMSimulator provides two trace modes &mdash; (1) **synthetic trace
mode** with which PNMSimulator executes memory traffic trace generated by
synthetic trace generator and (2) **real application trace mode** with which
PNMSimulator executes memory traffic trace of real application executed on
QEMU-based system. PNMSimulator is developed based on
[DRAMsim3](https://github.com/umd-memsys/DRAMsim3) [1].

## 2. CXL-PNM Architecture

CXL-PNM architecture includes one address decoder and one PNM block for each
channel.

```C
                                        |----------|
                                        |          |
|----------|       |------------|  (B)  |   PNM    |  (D)  |----------|
|          |  (A)  |            |-------|          |-------|          |
|   HOST   |-------|Addr.decoder|       |----------|       |Controller|
|          |       |            |--------------------------|          |
|----------|       |------------|           (C)            |----------|
```
* (A): CXL interface. Memory request from host.
* (B): PNM R/W
* (C): Normal memory R/W transaction
* (D): PNM memory R/W transaction

### 2.1. Address Decoder

Address Decoder determines whether the memory requests are for PNM or not. The 
memory region for PNM is allocated.

### 2.2. PNM Block

PNM block performs embedding lookup in memory and the elementwise summation.
After finishing SLS execution, the final result is transfered back to the host
via CXL interface. Please refer to [Section 3](#3-synthetic-trace-generator)
for more information about PNM read/write transactions.

## 3. Synthetic Trace Mode

With sunthetic trace mode, PNMSimulator executes memory traffic trace generated
by synthetic trace generator. Synthetic trace generator generates memory
traffic and instruction traces of SLS operations for CXL-PNM performance
simulator. It generates two types of traces &mdash; (1) CXL-PNM trace which
assumes that SLS operations are executed on CXL-PNM device and (2) baseline
trace which assumes that SLS operations are executed on host CPU.

The format of CXL-PNM trace is as follows:
```
# Write instruction to instruction buffer in PNM block
<addr> WRITE <time> <inst0> <inst1> ... <inst7>
<addr> WRITE <time> <inst0> <inst1> ... <inst7>
...
<addr> WRITE <time> <inst0> <inst1> ... <inst7>

# Wait until finishing instruction writing and execute SLS on PNM block.
<addr> SFENCE <time>
<addr> WRITE <time> 0xcafe

# Wait until finishing SLS execution and read PSUM buffer
<addr> DONE
<addr> READ <time>
<addr> READ <time>
...
<addr> READ <time>
```

The baseline trace consists of read transactions needed for embedding table
lookups.

Users can configure characteristics of SLS operations by using the following
command line parameters.

|Parameter|Description|Example|
|---|---|---|
|`opcode`|Code for operation. Currently, `trace-gen` support SLS operation (`opcode 0`).|`--opcode 0`|
|`nepochs`|Number of epochs (i.e., number of inferences with batch size of `batch_size`).|`--nepochs 2`|
|`batch_size`|Batch size.|`--batch_size 64`|
|`embedding_table`|List of embedding tables with sizes.|`--embedding_table "1000000-1000000"`|
|`num_tables`|Number of tables. If this parameter is set to a positive integer value `n`, `trace_gen` assumes that there are `n` tables and the size of each table is same with the size of the first table in `embedding_table` list.|`--num_tables 0`|
|`sparse_feature_size`|Feature size of embedding table.|`--sparse_feature_size 16`|
|`data_type_size`|Data type size of embedding table. Total size of a table is (# of indices) * (`sparse_feature_size`) * (`data_type_size`).|`--data_type_size 4`|
|`max_indices_per_lookup`|Maximum pooling size of a lookup.|`--max_indices_per_lookup 50`|
|`pooling_type`|FIXED (0): pooling size of each lookup is fixed to `max_indices_per_lookup`. <br /> RANDOM (1): pooling size of each lookup is randomly determined. <br/> PROD (2): pooling size of each lookup is determined by iterating `pooling_prod_list`.|`--pooling_type 0`|
|`pooling_prod_list`|List of pooling size when `pooling_type` is set to PROD (2).|`--pooling_prod_list "48-122-25-50"`|
|`default_interval`|Clock tick interval between memory transactions.|`--default_interval 4`|
|`miss_ratio`|Cache miss ratio for baseline memory trace.|`--miss_ratio 100`|
|`base_only`|If this option is set to `true`, `trace_gen` only generates baseline memory trace.|`--base_only false`|
|`channel`|List of CXL-PNM memory channels and channel IDs.|`--channel "0-1"`|
|`rank`|List of ranks and rank IDs per channel.|`--rank "0-1"`|
|`bg_size`|Number of bank groups per rank.|`--bg_size 4`|
|`ba_size`|Number of banks per bank group.|`--ba_size 4`|
|`ro_size`|Number of rows.|`--ro_size 65536`|
|`co_size`|Number of columns.|`--co_size 1024`|
|`bus_width`|Bus width.|`--bus_width 64`|
|`BL`|Burst length.|`--BL 8`|
|`address_mapping`|Address mapping (same format with DRAMsim3).|`--address_mapping "rochrababgco"`|
|`file_name`|Prefix of trace file name.|`--file_name "test"`|

## 4. Real Application Trace Mode

PNMSimulator also supports simulation for memory traffic trace of real
application. For more detailed information, please refer
`README_REAL_APP_MODE.md`.

## 5. How to Build

### 5.1. Prerequisites

- CMake 3.0+
- SCons

### 5.2. Build pnm_sim

1. Download DRAMsim3 and apply patch for CXL-PNM.

```
cd <PNMSimulator_path>/scripts
bash get_pnm_sim.sh
```

2. Build `pnm_sim`.

```
cd <PNMSimulator_path>/pnm_sim
mkdir build
cd build
cmake .. -DCMD_TRACE=1
# Enable address trace: cmake .. -DCMD_TRACE=1 -DADDR_TRACE=1

make -j
```

### 5.3. Build trace_gen

```
cd <PNMSimulator_path>/trace_gen

scons
```

## 6. How to Run with Synthetic Trace Generator

### 6.1. Choose configuration file for memory.

Edit configuration file path (`config_file`) in `run_trace_gen.sh` and
`run_pnm_sim.sh` in `script` directory.

Note: use the same configuation file for both scripts.

### 6.2. Run `trace_gen` to generate traces.

Before running the script, edit paramters for the trace genrator in the script.

Refer [Section 3](#3-synthetic-trace-generator) for the detailed information
about parameters.

```
cd <PNMSimulator_path>/scripts
bash run_trace_gen.sh
```

Then, trace files will be saved on `scripts/traces` directory.

### 6.3. Run `pnm_sim`.

```
cd <PNMSimulator_path>/scripts
bash run_pnm_sim.sh
```

The script will run the performance simulator with the traces in
`scripts/traces` directory and save the results on `results/res_<timestamp>`
directory.

## 7. Code Structure

```
PNMSimulator/               # Root directory of PNMSimulator
├─ pnm_sim/                 # Source code for the performance simulator
├─ trace_gen/               # Source code for the synthetic trace generator
├─ trace_conv/              # Source code for the trace converter
├─ scripts/                 # Scripts for building and running
├─ scripts_real_app_mode/   # Scripts for the real application trace mode
├─ configs/                 # Configuration files for memory
├─ results/                 # Created after running pnm_sim
├─ README.md                # This file
└─ README_REAL_APP_MODE.md  # README for the real application trace mode

```

[1] S. Li, Z. Yang, D. Reddy, A. Srivastava and B. Jacob, "DRAMsim3: a
Cycle-accurate, Thermal-Capable DRAM Simulator," in IEEE Computer Architecture
Letters. [Link](https://ieeexplore.ieee.org/document/8999595)
